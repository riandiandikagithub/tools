import { RequestConfig, TestResult, VulnerabilityTest, ScanReport } from '../types/vulnerability';
import { vulnerabilityTests } from '../data/vulnerabilityTests';

export class VulnerabilityScanner {
  private static async makeRequest(config: RequestConfig, payload?: string): Promise<Response> {
    const url = new URL(config.url);
    
    // Add query parameters
    Object.entries(config.params).forEach(([key, value]) => {
      url.searchParams.set(key, payload || value);
    });

    const headers = new Headers(config.headers);
    
    // Add authentication
    if (config.auth?.type === 'bearer' && config.auth.token) {
      headers.set('Authorization', `Bearer ${payload || config.auth.token}`);
    } else if (config.auth?.type === 'basic' && config.auth.username && config.auth.password) {
      const credentials = btoa(`${config.auth.username}:${config.auth.password}`);
      headers.set('Authorization', `Basic ${credentials}`);
    } else if (config.auth?.type === 'api-key' && config.auth.apiKey && config.auth.apiValue) {
      headers.set(config.auth.apiKey, payload || config.auth.apiValue);
    }

    let body: string | undefined;
    if (config.body && ['POST', 'PUT', 'PATCH'].includes(config.method)) {
      body = payload || config.body.content;
      
      if (config.body.type === 'json' && !headers.get('Content-Type')) {
        headers.set('Content-Type', 'application/json');
      } else if (config.body.type === 'xml' && !headers.get('Content-Type')) {
        headers.set('Content-Type', 'application/xml');
      } else if (config.body.type === 'form' && !headers.get('Content-Type')) {
        headers.set('Content-Type', 'application/x-www-form-urlencoded');
      }
    }

    const startTime = Date.now();
    
    try {
      const response = await fetch(url.toString(), {
        method: config.method,
        headers,
        body,
        mode: 'cors'
      });
      
      const endTime = Date.now();
      
      // Add timing information
      (response as any).responseTime = endTime - startTime;
      
      return response;
    } catch (error) {
      throw new Error(`Request failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private static async analyzeResponse(response: Response, test: VulnerabilityTest): Promise<TestResult> {
    const responseText = await response.text();
    const responseTime = (response as any).responseTime || 0;
    
    const result: TestResult = {
      id: `${test.id}-${Date.now()}`,
      testId: test.id,
      testName: test.name,
      status: 'passed',
      severity: test.severity,
      message: 'No vulnerability detected',
      timestamp: new Date(),
      response: {
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        body: responseText,
        time: responseTime
      }
    };

    // Analyze based on test type
    switch (test.id) {
      case 'broken-auth-weak-token':
        if (response.status === 200 && responseText.includes('admin')) {
          result.status = 'failed';
          result.message = 'Weak token accepted - possible authentication bypass';
          result.evidence = 'Server accepted weak authentication token';
        }
        break;

      case 'broken-auth-basic-no-tls':
        if (response.url.startsWith('http://') && response.headers.get('www-authenticate')?.includes('Basic')) {
          result.status = 'failed';
          result.message = 'Basic Authentication over HTTP detected';
          result.evidence = 'Basic auth without TLS encryption';
        }
        break;

      case 'sql-injection':
        const sqlIndicators = [
          'mysql_fetch_array',
          'ORA-01756',
          'Microsoft OLE DB Provider',
          'SQLServer JDBC Driver',
          'PostgreSQL query failed',
          'syntax error',
          'mysql_num_rows',
          'Warning: mysql_'
        ];
        
        if (sqlIndicators.some(indicator => responseText.toLowerCase().includes(indicator.toLowerCase()))) {
          result.status = 'failed';
          result.message = 'Possible SQL Injection vulnerability detected';
          result.evidence = 'Database error messages in response';
        } else if (response.status === 500) {
          result.status = 'warning';
          result.message = 'Server error - possible SQL injection impact';
        }
        break;

      case 'rce-detection':
        const rceIndicators = [
          'uid=',
          'gid=',
          'root:x:0:0',
          'www-data',
          'total 0',
          'drwxr-xr-x'
        ];
        
        if (rceIndicators.some(indicator => responseText.includes(indicator))) {
          result.status = 'failed';
          result.message = 'Remote Code Execution detected';
          result.evidence = 'Command execution output in response';
        }
        break;

      case 'path-traversal':
        const pathIndicators = [
          'root:x:0:0',
          '[boot loader]',
          'Windows Registry Editor',
          '/etc/passwd',
          'localhost'
        ];
        
        if (pathIndicators.some(indicator => responseText.includes(indicator))) {
          result.status = 'failed';
          result.message = 'Path Traversal vulnerability detected';
          result.evidence = 'System file content in response';
        }
        break;

      case 'sensitive-data-exposure':
        const sensitivePatterns = [
          /password\s*[:=]\s*[^*\s]+/i,
          /api[_-]?key\s*[:=]\s*[a-zA-Z0-9]{20,}/i,
          /secret\s*[:=]\s*[^*\s]+/i,
          /token\s*[:=]\s*[a-zA-Z0-9]{20,}/i
        ];
        
        if (sensitivePatterns.some(pattern => pattern.test(responseText))) {
          result.status = 'failed';
          result.message = 'Sensitive data exposure detected';
          result.evidence = 'Plaintext credentials or secrets found';
        }
        break;

      case 'idor-detection':
        if (response.status === 200 && responseText.includes('user')) {
          result.status = 'warning';
          result.message = 'Possible IDOR - unauthorized access to user data';
          result.evidence = 'User data accessible without proper authorization';
        }
        break;

      case 'ssrf-detection':
        if (response.status === 200 && (
          responseText.includes('169.254.169.254') ||
          responseText.includes('metadata') ||
          responseText.includes('ami-id')
        )) {
          result.status = 'failed';
          result.message = 'SSRF vulnerability detected';
          result.evidence = 'Internal/metadata service accessible';
        }
        break;

      case 'server-info-leak':
        const serverHeaders = ['server', 'x-powered-by', 'x-aspnet-version'];
        const leakedInfo = serverHeaders.filter(header => response.headers.get(header));
        
        if (leakedInfo.length > 0) {
          result.status = 'warning';
          result.message = 'Server information disclosure';
          result.evidence = `Headers: ${leakedInfo.join(', ')}`;
        }
        break;

      case 'debug-mode-detection':
        if (responseText.includes('DEBUG') || responseText.includes('stacktrace') || 
            responseText.includes('Exception') || response.headers.get('x-debug')) {
          result.status = 'warning';
          result.message = 'Debug mode detected';
          result.evidence = 'Debug information in response';
        }
        break;

      case 'directory-listing':
        if (responseText.includes('Index of /') || responseText.includes('Directory Listing')) {
          result.status = 'warning';
          result.message = 'Directory listing enabled';
          result.evidence = 'Directory contents exposed';
        }
        break;
    }

    return result;
  }

  static async runScan(config: RequestConfig, selectedTests: string[]): Promise<ScanReport> {
    const startTime = Date.now();
    const results: TestResult[] = [];
    
    const testsToRun = vulnerabilityTests.filter(test => 
      selectedTests.includes(test.id) && test.enabled
    );

    for (const test of testsToRun) {
      try {
        if (test.payloads && test.payloads.length > 0) {
          // Test with each payload
          for (const payload of test.payloads) {
            const testConfig = { ...config };
            
            // Inject payload into different parts of the request
            if (test.category === 'injection') {
              // For injection tests, modify URL parameters
              const url = new URL(testConfig.url);
              url.searchParams.set('test', payload);
              testConfig.url = url.toString();
            }
            
            const response = await this.makeRequest(testConfig, payload);
            const result = await this.analyzeResponse(response, test);
            result.details = `Payload: ${payload}`;
            results.push(result);
            
            // If vulnerability found, no need to test other payloads
            if (result.status === 'failed') break;
          }
        } else {
          // Single test without payloads
          const response = await this.makeRequest(config);
          const result = await this.analyzeResponse(response, test);
          results.push(result);
        }
      } catch (error) {
        results.push({
          id: `${test.id}-error-${Date.now()}`,
          testId: test.id,
          testName: test.name,
          status: 'warning',
          severity: 'low',
          message: `Test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
          timestamp: new Date()
        });
      }
    }

    const endTime = Date.now();
    
    // Calculate summary
    const summary = {
      critical: results.filter(r => r.severity === 'critical' && r.status === 'failed').length,
      high: results.filter(r => r.severity === 'high' && r.status === 'failed').length,
      medium: results.filter(r => r.severity === 'medium' && r.status === 'failed').length,
      low: results.filter(r => r.severity === 'low' && r.status === 'failed').length,
      passed: results.filter(r => r.status === 'passed').length
    };

    return {
      id: `scan-${Date.now()}`,
      url: config.url,
      timestamp: new Date(),
      duration: endTime - startTime,
      totalTests: results.length,
      results,
      summary
    };
  }
}