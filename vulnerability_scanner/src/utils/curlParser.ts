import { RequestConfig, CurlImport } from '../types/vulnerability';

export class CurlParser {
  static parse(curlCommand: string): RequestConfig {
    const config: RequestConfig = {
      url: '',
      method: 'GET',
      headers: {},
      params: {},
      auth: { type: 'none' }
    };

    // Remove 'curl' from the beginning and normalize spaces
    let cmd = curlCommand.replace(/^curl\s+/, '').trim();
    
    // Extract URL (first non-flag argument or -X flag value)
    const urlMatch = cmd.match(/(?:^|\s)(?!-[a-zA-Z])(['"]?)([^\s'"]+)\1(?=\s|$)/);
    if (urlMatch) {
      config.url = urlMatch[2];
      cmd = cmd.replace(urlMatch[0], '');
    }

    // Extract method
    const methodMatch = cmd.match(/-X\s+(['"]?)([A-Z]+)\1/i);
    if (methodMatch) {
      config.method = methodMatch[2].toUpperCase() as any;
    }

    // Extract headers
    const headerMatches = cmd.matchAll(/-H\s+(['"]?)([^'"]+)\1/g);
    for (const match of headerMatches) {
      const headerLine = match[2];
      const colonIndex = headerLine.indexOf(':');
      if (colonIndex > 0) {
        const key = headerLine.substring(0, colonIndex).trim();
        const value = headerLine.substring(colonIndex + 1).trim();
        config.headers[key] = value;
      }
    }

    // Extract data/body
    const dataMatch = cmd.match(/(?:-d|--data|--data-raw)\s+(['"]?)([^'"]+)\1/);
    if (dataMatch) {
      const bodyContent = dataMatch[2];
      let bodyType: 'raw' | 'json' | 'xml' | 'form' = 'raw';
      
      // Detect content type
      try {
        JSON.parse(bodyContent);
        bodyType = 'json';
      } catch {
        if (bodyContent.includes('<?xml')) {
          bodyType = 'xml';
        } else if (bodyContent.includes('=') && bodyContent.includes('&')) {
          bodyType = 'form';
        }
      }
      
      config.body = {
        type: bodyType,
        content: bodyContent
      };
      
      if (!config.method || config.method === 'GET') {
        config.method = 'POST';
      }
    }

    // Extract authentication
    const authMatch = cmd.match(/-u\s+(['"]?)([^'"]+)\1/);
    if (authMatch) {
      const authString = authMatch[2];
      if (authString.includes(':')) {
        const [username, password] = authString.split(':', 2);
        config.auth = {
          type: 'basic',
          username,
          password
        };
      }
    }

    // Extract bearer token from Authorization header
    const authHeader = config.headers['Authorization'] || config.headers['authorization'];
    if (authHeader && authHeader.startsWith('Bearer ')) {
      config.auth = {
        type: 'bearer',
        token: authHeader.substring(7)
      };
    }

    return config;
  }

  static importFromCurl(curlCommand: string): CurlImport {
    return {
      raw: curlCommand,
      parsed: this.parse(curlCommand)
    };
  }
}

export class RequestFormatter {
  static formatJson(jsonString: string): string {
    try {
      const parsed = JSON.parse(jsonString);
      return JSON.stringify(parsed, null, 2);
    } catch {
      return jsonString;
    }
  }

  static formatXml(xmlString: string): string {
    try {
      // Simple XML formatting
      let formatted = xmlString.replace(/></g, '>\n<');
      let indent = 0;
      const lines = formatted.split('\n');
      
      return lines.map(line => {
        const trimmed = line.trim();
        if (trimmed.startsWith('</')) {
          indent--;
        }
        const result = '  '.repeat(Math.max(0, indent)) + trimmed;
        if (trimmed.startsWith('<') && !trimmed.startsWith('</') && !trimmed.endsWith('/>')) {
          indent++;
        }
        return result;
      }).join('\n');
    } catch {
      return xmlString;
    }
  }

  static minifyJson(jsonString: string): string {
    try {
      const parsed = JSON.parse(jsonString);
      return JSON.stringify(parsed);
    } catch {
      return jsonString;
    }
  }
}